# 一、什么是微服务？

## 1、微服务概念

​	微服务是业界大牛马丁.福勒（*Martin Fowler* ）所提出来的一种架构风格，**就目前而言，对于微服务业界并没有统一的、标准的定义。**

​	[原版论文](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa) | [中文译本](http://blog.cuicc.com/blog/2015/07/22/microservices/)

​	但通常而言，微服务是一种架构模式/架构风格，它提倡将单一的应用划分为一组小的服务，每个服务运行在自己独立的进程中，服务与服务之间通过轻量级的通信机制（通常是基于HTTP的 RESTful API）相互通信、相互协调、相互配合，为用户提供最终的价值。服务可以由不同的语言开发，可以单独启动或销毁，甚至可以有自己独立的数据库。

## 2、从技术角度理解：

​	 微服务化的核心就是将传统的一站式应用，**根据业务**拆分成一个一个的服务，彻底地去藕合，每一个微服务提供单个业务功能的服务，**一个服务做一件事**，从技术角度看就是一种小而独立的处理过程，类似进程的概念，**能够自行单独启动或销毁，可以拥有自己独立的数据库。**

# 二、微服务与微服务架构

## 1、微服务

​	微服务强调的是服务的大小，它关注的是某一个点，是为具体某一个问题提供落地对应服务的一个服务应用，侠义的看，可以看作 Eclipse/IDEA 里面的一个个微服务工程/或者Module。

## 2、微服务架构

​	微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP 协议的RESTfulAPI ）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。

## 3、微服务与微服务的通俗理解

​	以现实中的综合医院来比喻，微服务架构就是一所综合医院，它对外提供综合医院的所有服务功能，而一个个微服务就是这所综合医院的一个个科室，比如骨科、眼科、肠胃科等，一个科室只负责一种疾病的治疗，如眼科只负责眼部疾病，肠胃科只负责肠胃疾病等。每个科室都是可以独立运转的，科室与科室之间通过电话等方式进行沟通与协作从而保证综合医院的运转，对外形成了一个提供多个服务的综合医院。

​	单个科室是可以脱离综合医院而独立运转的，如骨科脱离出来就成了骨科医院，专门治疗骨头问题，而综合医院却离不开这些一个个的科室。**即微服务可以脱离微服务架构单独运行，而微服务架构却离不开微服务，没了微服务的微服务架构就是个空架子，什么都做不了。**

# 三、微服务的优缺点

## 1、优点：

- **每个服务足够内聚，足够小，**使代码容易理解，能聚焦一个指定的业务功能或业务需求。
- **开发简单、开发效率提高，**一个服务可能就是专一的只干一件事。
- **微服务能够被小团队单独开发，**这个小团队是 2 到 5 人的开发人员组成。
- **微服务是松藕合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的**。
- **微服务能使用不同的语言开发**。
- **易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，**如Jenkins,Hudson,bamboo。
- **微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。**无需通过合作才能体现价值。微服务允许你利用融合最新技术。
- **微服务只是业务逻辑的代码，不会和 HTML,CSS或其他界面组件混合。**
- **每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。**

## 2、缺点：

- 开发人员要处理分布式系统的复杂性。
- 多服务的运维难度随着服务数量的增加而增大。
- 系统部署存在依赖。
- 服务间通信成本较高。
- 会带来数据一致性问题。
- 系统集成测试难度增大。

# 四、微服务技术栈

|                 服务条目                 |                        落地技术                        |
| :--------------------------------------: | :----------------------------------------------------: |
|                 服务开发                 |             SpringBoot、Spring、SpringMVC              |
|              服务配置与管理              |         Netflix公司的Archaius、阿里的Diamond等         |
|              服务注册与发现              |              Eureka、Consul、Zookeeper等               |
|                 服务调用                 |                 Restful API、RPC、gRPC                 |
|                服务熔断器                |                    Hystrix、Envoy等                    |
|                 负载均衡                 |                    Ribbon、Nginx等                     |
| 服务接口调用（客户端调用服务的简化工具） |                        Feign等                         |
|                 消息队列                 |              RabbitMQ、RocketMQ、Kafka等               |
|             服务配置中心管理             |               SpringCloudConfig、Chef等                |
|           服务路由（API网关）            |               Zuul、SpringCloudGateway等               |
|                 服务监控                 |          Metrics、Spectator、Zabbix、Nagios等          |
|                全链路追踪                |                Zipkin、Brave、Dapper等                 |
|                 服务部署                 |            Docker、OpenStack、Kubernetes等             |
|             数据流操作开发包             | SpringCloud Stream（封装与Redis、Rabbit、Kafka等发送） |
|               事件消息总线               |                    SpringCloud Bus                     |
|                    ……                    |                                                        |

# 五、为什么选择Spring Cloud？

## 1、选择依据

1. **整体解决方案和框架成熟度**

   ​	SpringCloud是微服务的一站式解决方案，它提供微服务开发所需的所有技术维度，经过Spring社区的多年维护，如今已十分成熟。

2. **社区热度**

   Spring是个开源社区，有多个开源项目，活跃度极高。

3. **可维护度【文档齐全度】**

   ​	SpringCloud的文档非常齐全，且Spring社区的活跃度很高，SpringCloud日常开发所遇到的坑也能通过他人的回答得到快速解决。

4. **学习曲线**

   ​	SpringCloud是将Spring项目下的多个子项目整合起来的，因为我们已经学过了Spring、SpringMVC、SpringBoot等，所以学习SpringCloud的代价相对较低。

## 2、Spring Cloud与Dubbo的对比

|                              | Dubbo         | Spring Cloud                 |
| ---------------------------- | ------------- | ---------------------------- |
| 服务注册中心                 | Zookeeper     | Spring Cloud Netflix Eureka  |
| **服务调用方式【主要】** | **RPC**   | **REST API**             |
| 服务监控                     | Dubbo-monitor | Spring Boot Admin            |
| 断路器                       | 不完善        | Spring Cloud Netflix Hystrix |
| 服务网关                     | 无            | Spring Cloud Netflix Zuul    |
| 分布式配置中心               | 无            | Spring Cloud Config          |
| 服务跟踪                     | 无            | Spring Cloud Sleuth          |
| 消息总线                     | 无            | Spring Cloud Bus             |
| 数据流                       | 无            | Spring Cloud Stream          |
| 批量任务                     | 无            | Spring Cloud Task            |
| ......                       | ......        | ......                       |

**最大的区别：Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式。**
	严格来说，这两种方式各有优劣。虽然在一定程度上来说，SpringCloud牺牲了服务调用的性能，但也避免了原生RPC带来的问题。而且**REST相比RPC更为灵活**，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适。

## 3、总结：

​	Dubbo和Spring Cloud并不是完全的竞争关系，两者所解决的问题域不一样：**Dubbo的定位始终是一款RPC框架，而Spring Cloud的目的是微服务架构下的一站式解决方案。**
​	非要比较的话，Dubbo可以类比到Netflix OSS技术栈，而Spring Cloud集成了Netflix OSS作为分布式服务治理解决方案，但除此之外Spring Cloud还提供了包括config、stream、security、sleuth等分布式服务解决方案。
当前由于RPC协议、注册中心元数据不匹配等问题，在面临微服务基础框架选型时Dubbo与Spring Cloud只能二选一，这也是两者总拿来做对比的原因。
​	**Dubbo之后会积极寻求适配到Spring Cloud生态，比如作为SpringCloud的二进制通讯方案来发挥Dubbo的性能优势，或者Dubbo通过模块化以及对http的支持适配到Spring Cloud。**

# 六、服务注册与发现

## 1、为什么需要服务注册与发现？

在微服务应用中，**运行的服务实例集会动态更改，实例能动态分配网络位置**，所以为了使客户端发出的请求请能定位到指定的服务中，它需要使用服务注册与服务发现机制。

​	**服务注册**就是将服务提供者注册到服务注册中心中，对外暴露调用服务的入口【IP地址与端口号】。

​	**服务发现**就是当客户端应用进程向注册中心发起请求时，用来从已注册的服务列表中，定位到具体的服务上去。

## 2、Eureka与Zookeeper的区别

|                 Feature                 |            Eureka            |       Zookeeper       |
| :-------------------------------------: | :--------------------------: | :-------------------: |
|              服务健康检查               |           可配支持           | (弱)长连接，keepalive |
|         **CAP理论【主要】**         |          **AP**          |      **CP**       |
| watch支持（客户端观察到服务提供者变化） | 支持 long polling/大部分增量 |         支持          |
|                自我保护                 |             支持             |           -           |
|               客户端缓存                |             支持             |           -           |
|             自身集群的监控              |           metrics            |           -           |

## 3、为什么选用 Eureka？

​	著名的CAP理论指出，一个分布式系统不可能同时满足C（强一致性）、A（高可用性）和P（分区容错性），最多只能三选二。

​	由于现阶段网络原因，分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP【强一致性与分区容错性】，而Eureka则是AP【高可用性与分区容错性】。

### 1、 Zookeeper保证CP

​	当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。

​	但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，**leader选举leader的时间太长，30  ~ 120s,  且选举期间整个zk集群都是不可用的**，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是有较大概率会发生的，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。

 

### 2、Eureka保证AP

​	Eureka明白了Zookeeper的缺点，因此在设计时就优先保证可用性。**Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或发现连接失败时，则会自动切换至其它节点，所以只要还有一个Eureka节点正常，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。**除此之外，Eureka还有一种自我保护机制：如果在**15分钟**内超过**85%**的节点都没有正常的心跳（30s/次，超过90s失效），那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：  

1. Eureka不再从注册列表中移除（默认超过60s就会移除）因为长时间没收到心跳而应该过期的服务 。
2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即仅保证当前节点依然可用) 。
3. 当网络稳定时，当前实例新的注册信息才会被同步到其它节点中。

### 3、总结

​	由上可知， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况，但却接受不了服务直接挂掉的情况。

# 七、负载均衡

## 1、Nginx与Ribbon的区别

- nginx是客户端的所有请求统一交给nginx，由nginx进行负载均衡实现与请求转发，属于**服务器端负载均衡**。

  即请求由nginx服务器端进行转发。

- Ribbon是从eureka注册中心服务器端上获取服务注册信息列表，**缓存到本地**，然后在本地默认实现**轮训负载均衡策略**。即在客户端实现负载均衡，属于**客户端负载均衡**。

- Nginx适合于服务器端实现负载均衡，比如Tomcat、Jetty；Ribbon适合于在微服务中HTTP Restful API或RPC远程调用，在客户端本地实现负载均衡，比如Dubbo、SpringCloud中都是采用本地负载均衡。

## 2、Ribbon与Feign的区别

- Ribbon是一个基于HTTP和TCP的**客户端负载均衡**工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的RestTemplate请求，自动转换成客户端负载均衡的服务调用。
- Feign是接口+注解的声明式Web服务客户端，它对Ribbon做了封装，使得编写Web服务客户端变得更加容易，底层还是由Ribbon来实现负载均衡。Feign只需要创建一个接口，然后在接口上面加上注解即可使用。

# 八、API网关

## 1、定义

API网关是系统的单个入口服务器，封装了内部系统的架构并为每个客户端提供定制的API。它可能还有其他的职责，比如身份验证、负载均衡、缓存、服务代理、监控、日志等。

## 2、优点

**流量统一管理和路由。**用于解决微服务过于分散，没有一个统一的出入口进行流量管理、路由映射、监控、缓存、负载均衡等问题。

## 3、缺点

1. 增加系统的复杂度。
2. API网关是系统的入口，所以它必须被开发、部署和管理为一个高可用的组件。
3. 有可能会变成系统开发的瓶颈。开发人员必须更新API网关来暴露每个微服务接口，因此更新API网关的过程应越少越好。

## 4、SpringCloud中的API网关

### 1、ZUUL

### 2、SpringCloud Gateway



# 九、服务容错保护Hystrix

## 1、服务降级

​	在用户访问量高峰期，**整体资源**面临不足的时候，将一些重要优先程度相对较低的服务先关掉，等到过了高峰期再恢复。比如京东商城在双十一期间，可能会对评论服务进行服务降级。

​	服务A调用服务B，当我们对服务B进行降级后，服务A将直接调用预定义的降级逻辑（即方法调用代替跨服务请求），从而快速获取返回结果，而降级方法逻辑的返回结果与真实服务B的返回结果的**区别就好比残次品与良品的区别**，此时我们认为服务B所提供的服务质量降低了，即我所说的降级。

```java
// 主逻辑
@FeignClient(value = "mst-goods-service", fallback = GoodClientFallback.class)
public interface GoodsClient {
    @RequestMapping(method = RequestMethod.GET, path = "/api/goods/{goods_id}")
    GoodsDTO getOne(@PathVariable("goods_id") Long goodsId);
}

// 降级逻辑
@Component
public class GoodClientFallback implements GoodsClient {
    @Override
    public GoodsDTO getOne(Long goodsId) {
        return new GoodsDTO(1l, 12.3, 2l, "name");
    }
}
```

## 2、服务熔断

​	在分布式架构中，断路器模式的作用也是类似的，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不再调用目标服务，直接返回结果，快速释放资源，避免最终因为服务不可用蔓延导致系统雪崩灾难。

​	服务不可用蔓延：在微服务架构中，各服务之间存在相互调用，当关键服务不可用时，可能造成其他服务阻塞，当服务阻塞过多时，就可能会导致系统崩溃。

​	如：A、B、C服务都调用D服务，当D服务不可用时，则A、B、C就会被阻塞，而其他服务调用A、B、C时也会阻塞，如此阻塞就会蔓延……

### 1、断路器什么时候会打开

这里涉及到断路器的三个重要参数：

1. 快照时间窗**【默认10s】**：

   在开启断路器前，需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，**默认10秒**。

2. 请求总数下限（RequestVolumeThreshold）**【默认20次】**：

   在快照时间窗内，必须满足请求总数下限才会启用熔断。默认20次，**意味着在10秒内，如果调用不足20次，即便所有的请求都失败，断路器都不会打开。**

3. 错误百分比下限（ErrorThresholdPercentage）**【默认50%】**：

   **即在快照时间窗规定的时间内【10s】，请求次数超过了请求总数下限【20次】，且请求失败次数占比达到50%以上时，断路器就会打开。**

   当请求总数在快照时间内超过了下限，比如发生了30次调用，如果在这 30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限的情况下，断路器就会打开。

### 2、断路器打开之后发生什么

​	即说明服务被熔断/或降级了，这个时候再有请求过来，将不会调用主逻辑，而是直接调用降级逻辑进行快速响应。也就是说不会再去处理原来的业务逻辑代码，而是快速返回一个预设好的结果，不再等待到超时【默认5秒】之后才进行降级响应。

​	这样做的好处：通过断路器**实现了自动发现错误并将降级逻辑切换为主逻辑，减少了响应延迟的效果，避免因服务不可用蔓延导致系统雪崩灾难**。

### 3、主逻辑如何恢复

​	Hystrix熔断器启动时，会启动一个休眠时间窗【**默认5000ms**】，在这个时间窗内，降级逻辑临时成为主逻辑，当休眠时间窗到期时，断路器就进入**半开状态**。

​	在半开状态下，熔断器会释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将会关闭，然后原来的主逻辑恢复正常，否则，断路器继续保持打开状态，而休眠时间窗也会重新计时。

[**断路器Hystrix代码实例**](https://doocs.github.io/advanced-java/#/docs/high-availability/hystrix-circuit-breaker?id=%E5%AE%9E%E4%BE%8B-demo)

# 十、服务配置中心

​	在微服务架构中，每个服务的配置文件都是在自身代码库中，当服务个数达到一定数量后，如何管理这些分散的配置文件将变得十分麻烦。

​	Spring Cloud Config的目标是**将各个微服务的配置文件集中存储一个文件仓库中（比如系统目录、GitHub仓库等），然后通过Config Server从文件仓库中去读取配置文件，而各个微服务作为Config Client通过给Config Server发送请求指令来获取特定的Profile配置文件，从而为自身的应用提供配置信息。同时还提供配置文件自动刷新功能。**[如何使用？](https://sjyuan.cc/service-config-server/)

![](../img/服务配置中心.jpg)